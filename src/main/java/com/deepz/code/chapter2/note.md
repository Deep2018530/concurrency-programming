## 对象及变量的并发访问

* 非线程安全问题存在于实例变量中，对于方法内部的私有变量，则不存在非线程安全问题，结果是“线程安全”的。

* 如果多个线程共同访问一个对象中的实例变量，则运行的结果有可能出现交叉的情况。

* 两个线程同时访问同一个对象中的同步方法时一定是线程安全的。

#### synchronizedMethodLockObject2

* 结论：
1. A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。
2. A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的synchronized类型的方法，则需要等待，也就是说同步。
3. **在方法声明处添加synchronized并不是锁方法，而是锁当前类的对象。**
4. 在Java中只有"将对象作为锁"这种说法，并没有"锁方法"这种说法。
5. 在Java语言中，"锁"就是"对象","对象"可以映射成"锁"，哪个线程拿到这把锁，哪个线程就可以执行这个对象中的synchronized同步方法。
6. 如果在X对象中使用了synchronized关键字声明非静态方法，则X对象就被当成锁。

`备注:`示例代码在标题包中的**note.md**里的代码总览中可以查看。

#### 脏读   t3

线程A对某对象的两个字段进行修改，修改第一个字段后再修改第二个字段前，由于种种原因耗了些时间，而在修改第二个字段前，
其他线程调用了读字段的方法，这时候的数据可能就会是，第一个字段是被修改的，第二个字段是原来的，这就出现了数据`交叉`的情况，解决办法是让读数据的方法同步。

#### synchronized锁重入  synLockln_1

关键字synchronized拥有重入锁的功能，即在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以得到该对象锁的，这也证明在一个synchronized方法/块的内部调用
本类的其他synchronized方法/块时,是**永远可以得到锁的**。

* “可重入锁”是指自己可以再次获得自己的内部锁。例如一个线程获得了某个对象锁，此时这个对象锁还没有释放，当其再次想要获取这个对象锁时还是可以获取的，如果不可重入锁，则方法service2()不会被调用,方法service3()更不会被调用。`代码见包synLockln_1`

#### 锁重入支持继承的环境  synLockln_2

> 当存在父子类继承关系时，子类是完全可以通过锁重入调用父类的同步方法的。


* 出现异常，锁会自动释放。

#### synchronized同步语句块

用关键字synchronized声明方法在某些情况下是有弊端的，例如A线程调用同步方法执行一个长时间的任务，那么B线程等待的时间就比较长，这种情况可以使用synchronized同步语句块来解决，以提高运行效率。

synchronized方法是将当前对象作为锁，而synchronized代码块是将任意对象作为锁。可以将锁看成一个标识，哪个线程持有这个标识，就可以执行同步方法。

> 通过包`t6`中的代码可以发现，当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非synchronized(this)同步代码块。